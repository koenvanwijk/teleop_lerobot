#!/usr/bin/env python3
"""
Genereer udev-regels uit mapping.csv voor USB-serial apparaten.
"""

import argparse
import os
import re
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path


def parse_line(line: str) -> tuple[str, str, str, str] | None:
    """
    Parse √©√©n regel uit mapping.csv.
    Returns: (serial, nice, role, robot_type) of None als de regel overgeslagen moet worden.
    """
    # Trim whitespace
    line = line.strip()
    
    # Skip lege regels en commentaar
    if not line or line.startswith("#"):
        return None
    
    # Normaliseer: vervang tabs en multiple spaces door komma's
    norm = re.sub(r'[\t ]+', ',', line)
    
    # Split op komma's
    parts = [p.strip() for p in norm.split(',')]
    
    if len(parts) < 3:
        return None
    
    serial, nice, role = parts[0], parts[1], parts[2]
    robot_type = parts[3] if len(parts) > 3 else "so101"  # Default naar so101
    
    # Valideer dat velden niet leeg zijn
    if not serial or not nice or not role:
        return None
    
    # Sanitize serial: alleen alphanumeriek
    serial = re.sub(r'[^a-zA-Z0-9]', '', serial)
    
    # Sanitize nice: lowercase, vervang non-alphanumeric door underscore
    nice = nice.lower()
    nice = re.sub(r'[^a-z0-9_]', '_', nice)
    
    # Sanitize role: lowercase
    role = role.lower()
    
    # Sanitize robot_type: lowercase, alleen alphanumeriek
    robot_type = robot_type.lower()
    robot_type = re.sub(r'[^a-z0-9]', '', robot_type)
    
    # Valideer role
    if role not in ("leader", "follower"):
        return None
    
    return serial, nice, role, robot_type


def read_mapping(mapfile_path: Path) -> list[tuple[str, str, str, str]]:
    """
    Lees en parse mapping.csv bestand.
    Returns: lijst van (serial, nice, role, robot_type) tuples.
    """
    if not mapfile_path.exists():
        print(f"‚ùå Mapping niet gevonden: {mapfile_path}", file=sys.stderr)
        sys.exit(1)
    
    print(f"üîß Genereer udev-regels uit {mapfile_path}‚Ä¶")
    
    entries = []
    
    with open(mapfile_path, 'r', encoding='utf-8') as f:
        for line_num, raw in enumerate(f, 1):
            parsed = parse_line(raw)
            if parsed:
                entries.append(parsed)
            elif raw.strip() and not raw.strip().startswith("#"):
                print(f"‚ö†Ô∏è  Overslaan regel {line_num}: {raw.strip()}", file=sys.stderr)
    
    return entries

def generate_udev_rules(entries: list[tuple[str, str, str, str]], script_name: str) -> str:
    """
    Genereer udev rules content.
    Returns: string met complete udev rules inhoud.
    """
    lines = [
        f"# Auto-generated by {script_name} on {datetime.now()}",
        "# Kolommen: SERIAL_SHORT,NICE_NAME,ROLE,TYPE",
        "# Symlinks: /dev/tty_<nice>_<role>_<type> en /dev/tty_follower (voor role=follower)",
    ]
    
    for serial, nice, role, robot_type in entries:
        if role == "follower":
            rule = (
                f'SUBSYSTEM=="tty", ENV{{ID_BUS}}=="usb", '
                f'ENV{{ID_SERIAL_SHORT}}=="{serial}", '
                f'SYMLINK+="tty_{nice}_{role}_{robot_type}", SYMLINK+="tty_follower"'
            )
        else:  # leader
            rule = (
                f'SUBSYSTEM=="tty", ENV{{ID_BUS}}=="usb", '
                f'ENV{{ID_SERIAL_SHORT}}=="{serial}", '
                f'SYMLINK+="tty_{nice}_{role}_{robot_type}", SYMLINK+="tty_leader"'
            )
        lines.append(rule)
    
    return "\n".join(lines) + "\n"


def write_udev_rules(content: str, udev_rule: Path) -> None:
    """Schrijf udev rules naar bestand."""
    print(f"üìù Schrijf naar {udev_rule}‚Ä¶")
    with open(udev_rule, 'w', encoding='utf-8') as f:
        f.write(content)




def main():
    parser = argparse.ArgumentParser(
        description="Genereer udev-regels uit mapping.csv voor USB-serial apparaten."
    )
    parser.add_argument(
        "mapfile",
        nargs="?",
        default="./mapping.csv",
        help="Pad naar mapping.csv bestand (standaard: ./mapping.csv)"
    )
    parser.add_argument(
        "--output",
        default="/etc/udev/rules.d/99-usb-serial-aliases.rules",
        help="Output pad voor udev rules (standaard: /etc/udev/rules.d/99-usb-serial-aliases.rules)"
    )
    
    args = parser.parse_args()
    
    mapfile_path = Path(args.mapfile)
    udev_rule = Path(args.output)
    
    # Lees en parse mapping
    entries = read_mapping(mapfile_path)
    
    if not entries:
        print("‚ö†Ô∏è  Geen geldige entries gevonden in mapping bestand", file=sys.stderr)
        sys.exit(1)
    
    # Genereer udev rules
    content = generate_udev_rules(entries, script_name=sys.argv[0])
    
    # Schrijf naar bestand
    write_udev_rules(content, udev_rule)
    
    print("‚úÖ Udev rules succesvol gegenereerd!")


if __name__ == "__main__":
    main()
